<!DOCTYPE html>
<html>
    <style>
        table,td,th{
            border: 1px solid;
        }
    </style>
<head>
<title>My Introduction</title>
</head>
<body>

<h1>Anakapalli Phaneendra Babu</h1>
<h3>Visakapatnam</h3>
<p>Looking at the breezy mornings everyday in Vizag makes everyone want to go on a long drive to their
     favourite beach. Itâ€™s a daily habit for Vizagites to go for early morning walks, maybe some 
     tea/coffee at RK Beach or a breakfast full of Dosa/Idli. If we want to hang out with friends, the 
     Maggi Point at <strong>Rushikonda Beach</strong> is one of the most sought-after places in Vizag where young 
     people, especially students, come together and have a <strong> of Maggi by the beach. </strong>  No matter 
     what your empty belly desires in the morning, the various eateries in Vizag have some delicious 
     food waiting for you.</p>
     <hr>
        <h4>Ordered List</h4>
        <ol>
            <li>You can also find the distance from Visakhapatnam Airport to R K Beach using other travel options like bus.</li>
            <li>Subway, tram, train and rail, apart from the trip distance.</li>
            <li>Refer Directions from Visakhapatnam Airport to R K Beach for road driving directions!</li>
            <li>Favourite food destination in RK beach is arrived.</li>  
        </ol>
        <ul>
            <li>Muri Mixture. A Muri Mixture vendor at RK Beach.</li>
            <li>Tomato Bajji. Bajji Cart at Double Road.</li>
            <li>Punugulu. Sumptuous punugulu.</li>
            <li>Sweet Corn. Sweet corn vendors.</li>
            <li>Dosa. Dosa with peanut chutney.</li>
            <li>Liver Kebab. Liver and chicken kebab.</li>
            <li>Idli. Midnight Idli at Rly Station.</li>
            <li>Masala Batani. Masala Batani in a bowl.</li>
        </ul>
        <a href="aboutme.html">Click to AboutMe</a>
        <hr>
        <h3>Adding Table</h3>
        <table>
            <tr>
                <th>Game Name</th>
                <th>Location</th>
                <th>Money</th>
            </tr>
            <tr>
                 <td>Swimming</td>
                 <td>Hyderabad</td>
                 <td>200$</td>
            </tr>
            <tr>
                 <td>Football</td>
                 <td>Vizag</td>
                 <td>250$</td>
            </tr>
            <tr>
                 <td>Cricket</td>
                 <td>Chennai</td>
                 <td>300$</td>
            </tr>
            <tr>
                 <td>Golf</td>
                 <td>Banglore</td>
                 <td>350$</td>
            </tr>
 
         </table>

         <hr>
         <h3>Algorithms</h3>
         <blockquote>A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a 
            connected, edge-weighted undirected graph that connects all the vertices together, without 
            any cycles and with the minimum possible total edge weight.[1] That is, it is a spanning 
            tree whose sum of edge weights is as small as possible.[2] More generally, any edge-weighted 
            undirected graph (not necessarily connected) has a minimum spanning forest, which is a union 
            of the minimum spanning trees for its connected components.</blockquote>
        <a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree#:~:text=A%20minimum%20spanning%20tree%20(MST,minimum%20possible%20total%20edge%20weight.&text=There%20are%20many%20use%20cases%20for%20minimum%20spanning%20trees.">Link to Algorithm</a>
        <h4>Graph spanning - Breadth first search</h4>
        <pre>
            vector<vector<int>> adj;  // adjacency list representation
                int n; // number of nodes
                int s; // source vertex
                
                queue<int> q;
                vector<bool> used(n);
                vector<int> d(n), p(n);
                
                q.push(s);
                used[s] = true;
                p[s] = -1;
                while (!q.empty()) {
                    int v = q.front();
                    q.pop();
                    for (int u : adj[v]) {
                        if (!used[u]) {
                            used[u] = true;
                            q.push(u);
                            d[u] = d[v] + 1;
                            p[u] = v;
                        }
                    }
                }
                
        </pre>

        <a href="https://cp-algorithms.com/graph/breadth-first-search.html">Link to Code</a>

</body>
</html>  
        
